module BlasLevel1;

use Structures: all;
use Math: all;
use Helper: all;

export all;

/*
 * srotg
 */
inline
float, float, float, float srotg(float a, float b, float c, float s)
{
  if(b == 0f) {
    r = a;
    z = 0f;
    c = 1f;
    s = 0f;
  } else if(a == 0f) {
    r = b;
    z = 1f;
    c = 0f;
    s = 1f;
  } else {
    sigma = tof(abs(a) > abs(b) ? sign(a) : sign(b));
    r = sigma * sqrtf(a*a + b*b);
    c = a/r;
    s = b/r;
    z = abs(a) > abs(b) ? s : c == 0f ? 1f : 1f/c;
  }
  return (r, z, c, s);
}


/*
 * srotmg
 */
inline
float, float, float, float[5] srotmg(float d1, float d2, float x1, float y1)
{
  //A very literal translation from Fortran
  gam    = 4096f;
  gamsq  = 1.67772e7f;
  rgamsq = 5.96046e-8f;

  sflag = 0f;
  sh11 = 0f;
  sh21 = 0f;
  sh12 = 0f;
  sh22 = 0f;

  if(d1 < 0f) {
    sflag = -1f;
    d1 = 0f;
    d2 = 0f;
    x1 = 0f;
  } else if(d2*y1 == 0f) {
    sflag = -2f;
  } else {
    sp2 = d2*y1;
    sp1 = d1*x1;
    sq2 = sp2*y1;
    sq1 = sp1*x1;

    if(abs(sq1) > abs(sq2)) {
      sh21 = -y1/x1;
      sh12 = sp2/sp1;
      su = 1f - sh12*sh21;

      if(su > 0f) {
        sflag = 0f;
        d1 /= su;
        d2 /= su;
        x1 *= su;
      } else {
        sflag = -1f;
        sh11 = 0f;
        sh21 = 0f;
        sh12 = 0f;
        sh22 = 0f;
        d1 = 0f;
        d2 = 0f;
        x1 = 0f;
      }
    } else {
      if(sq2 < 0f) {
        sflag = -1f;
        sh11 = 0f;
        sh21 = 0f;
        sh12 = 0f;
        sh22 = 0f;
        d1 = 0f;
        d2 = 0f;
        x1 = 0f;
      } else {
        sflag = 1f;
        sh11 = sp1/sp2;
        sh22 = x1/y1;
        su = 1f + sh11*sh22;
        stemp = d2/su;
        d2 = d1/su;
        d1 = stemp;
        x1 = y1*su;
      }
    }

    if(d1 != 0f) {
      while((d1 < rgamsq) || (d1 > gamsq)) {
        if(sflag == 0f) {
          sh11 = 1f;
          sh22 = 1f;
        } else {
          sh21 = -1f;
          sh12 = 1f;
        }

        sflag = -1f;

        if(d1 < rgamsq) {
          d1 *= gam * gam;
          x1 /= gam;
          sh11 /= gam;
          sh12 /= gam;
        } else {
          d1 /= gam*gam;
          x1 *= gam;
          sh11 *= gam;
          sh12 *= gam;
        }
      }
    }

    if(d2 != 0f) {
      while((abs(d2) < rgamsq) || (abs(d2) > gamsq)) {
        if(sflag == 0f) {
          sh11 = 1f;
          sh22 = 1f;
        } else {
          sh21 = -1f;
          sh12 = 1f;
        }

        sflag = -1f;

        if(abs(d2) < rgamsq) {
          d2 *= gam * gam;
          sh21 /= gam;
          sh22 /= gam;
        } else {
          d2 /= gam*gam;
          sh21 *= gam;
          sh22 *= gam;
        }
      }
    }
  }

  return (d1, d2, x1, [sflag, sh11, sh21, sh12, sh22]);
}


/*
 * srot
 * incx and incy do not have to be > 0 but inverse matrix is not implemented
 * 
 */
inline
float[xn], float[yn] srot(int n, float[xn] x, int incx, float[yn] y, int incy, float c, float s) | n > 0, incx > 0, incy > 0
{
  return (
    {iv -> c*x[iv] + s*y[(iv*incy)/incx] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]},
    {iv -> c*y[iv] - s*x[(iv*incx)/incy] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]}
  );
}


/*
 * srotm
 */
inline
float[xn], float[yn] srotm(int n, float[xn] x, int incx, float[yn] y, int incy, float[5] param) | n > 0, ismember(param[0], [1.0f, 0.0f, -1.0f, -2.0f]), minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  sflag = param[0];
  sh11  = param[1];
  sh21  = param[2];
  sh12  = param[3];
  sh22  = param[4];
  
  if(n < 1 || sflag == -2f) {
    x_prime = x;
    y_prime = y;
  } else if(sflag < 0f) {
    x_prime = {iv -> x[iv]*sh11 + y[(iv*incy)/incx]*sh12 | [0] <= iv < [xn] step [incx] ; iv -> x[iv]};
    y_prime = {iv -> x[(iv*incx)/incy]*sh21 + y[iv]*sh22 | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
  } else if(sflag == 0f) {
    x_prime = {iv -> x[iv] + y[(iv*incy)/incx]*sh12 | [0] <= iv < [xn] step [incx] ; iv -> x[iv]};
    y_prime = {iv -> x[(iv*incx)/incy]*sh21 + y[iv] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
  } else {
    x_prime = {iv ->  x[iv]*sh11 + y[(iv*incy)/incx] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]};
    y_prime = {iv -> -x[(iv*incx)/incy] + y[iv]*sh22 | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
  }
  
  return (x_prime, y_prime);
}


/*
 * sswap
 */
// Does this work for swapping things with the same indices?
inline
float[xn], float[yn] sswap(int n, float[xn] x, int incx, float[yn] y, int incy) | n > 0, incx > 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return (
    {iv -> y[(iv/incx)*incy] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]},
    {iv -> x[(iv/incy)*incx] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]}
  );
}


/*
 * sscal
 */
inline
float[xn] sscal(int n, float a, float[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  return {iv -> a * x[iv] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]};
}


/*
 * scopy
 */
inline
float[yn] scopy(int n, float[xn] x, int incx, float[yn] y, int incy) | n > 0, incx >= 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return {iv -> x[(iv/incy)*incx] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
}


/*
 * saxpy
 */
inline
float[yn] saxpy(int n, float sa, float[xn] x, int incx, float[yn] y, int incy) | n > 0, incx >= 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  if(sa == 0f) {
    result = y;
  } else {
    result = {iv -> sa * x[(iv/incy)*incx] + y[iv] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
  }
  return result;
}


/*
 * sdot
 */
inline
float sdot(int n, float[xn] x, int incx, float[yn] y, int incy) | n > 0, incx >= 0, incy >= 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return sum( {iv -> x[iv*incx] * y[iv*incy] | [0] <= iv < [n]} );
}


/*
 * sdsdot
 */
inline
double sdsdot(int n, float sb, float[xn] x, int incx, float[yn] y, int incy) | n > 0, incx >= 0, incy >= 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return tod(sb) + sum( {iv -> tod(x[iv*incx]) * tod(y[iv*incy]) | [0] <= iv < [n] } );
}

/*
 * snrm2
 */
inline
float snrm2(int n, float[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  return sqrtf(sum( {iv -> x[iv]*x[iv] | [0] <= iv < [xn] step [incx]} ));
}


// Creates compiler core dump error
// /*
//  * scnrm2
//  */
// inline
// float scnrm2(int n, complex[.] x, int incx) //| n > 0, incx > 0
// {
//   x_prime = {i -> x[i*incx] | [0] <= i < [n] ; i -> zero() | i < [n*incx]};
//   return sqrtf(tof(sum(normSq(x_prime))));
// }


/*
 * sasum
 */
inline
float sasum(int n, float[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  return sum( {iv -> abs(x[iv]) | [0] <= iv < [xn] step [incx]} );
}


/*
 * isamax
 */
inline
int isamax(int n, float[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  max_i = 0;
  max_v = 0f;
  ix = 0;
  for(i = 0; i < n; i++) {
    if(abs(x[ix]) > max_v) {
      max_i = i;
      max_v = abs(x[ix]);
    }
    ix += incx;
  }

  return max_i;
}


/*
 * drotg
 */
inline
double, double, double, double drotg(double a, double b)
{
  if(b == 0d) {
    r = a;
    z = 0d;
    c = 1d;
    s = 0d;
  } else if(a == 0d) {
    r = b;
    z = 1d;
    c = 0d;
    s = 1d;
  } else {
    sigma = tod(abs(a) > abs(b) ? sign(a) : sign(b));
    r = sigma * sqrt(a*a + b*b);
    c = a/r;
    s = b/r;
    z = abs(a) > abs(b) ? s : c == 0d ? 1d : 1d/c;
  }
  return (r, z, c, s);
}


/*
 * drotmg
 */
inline
double, double, double, double[5] drotmg(double d1, double d2, double x1, double y1)
{
  //A very literal translation from Fortran
  gam    = 4096d;
  gamsq  = 16777216d;
  rgamsq = 5.9604645e-8d;

  flag = 0d;
  h11  = 0d;
  h21  = 0d;
  h12  = 0d;
  h22  = 0d;

  if(d1 < 0d) {
    flag = -1d;
    
    d1 = 0d;
    d2 = 0d;
    x1 = 0d;
  } else if(d2*y1 < 0d) {
    flag = -2d;
  } else {
    p1 = d1*x1;
    p2 = d2*y1;
    q1 = p1*x1;
    q2 = p2*y1;

    if(abs(q1) > abs(q2)) {
        h21 = (-y1)/x1;
        h12 = p2/p1;

        u = 1d - h12*h21;
        if(u > 0d) {
            flag = 0d;
            d1 /= u;
            d2 /= u;
            x1 /= u;
        } else {
            flag = -1d;
            d1 = 0d;
            d2 = 0d;
            x1 = 0d;
        }
    } else {
        if(q2 < 0d) {
            flag = -1d;
            d1 = 0d;
            d2 = 0d;
            x1 = 0d;
        } else {
            flag = 1d;
            h11 = p1/p2;
            h22 = x1/y1;
            u = 1d + h11*h22;
            temp = d2/u;
            d2 = d1/u;
            d1 = temp;
            x1 = y1*u;
        }
    }

    if(d1 != 0d) {
        while(d1 < rgamsq || d1 > gamsq) {
            if(flag == 0d) {
                h11 = 1d;
                h22 = 1d;
                flag = -1d;
            } else {
                h21 = -1d;
                h12 = 1d;
                flag = -1d;
            }
            if(d1 < rgamsq) {
                d1 *= gam*gam;
                x1 /= gam;
                h11 /= gam;
                h12 /= gam;
            } else {
                d1 /= gam*gam;
                x1 *= gam;
                h11 *= gam;
                h12 *= gam;
            }
        }
    }

    if(d2 != 0d) {
        while(abs(d2) < rgamsq || abs(d2) > gamsq) {
            if(flag == 0d) {
                h11 = 1d;
                h22 = 1d;
                flag = -1d;
            } else {
                h21 = -1d;
                h12 = 1d;
                flag = -1d;
            }
            if(abs(d2) < rgamsq) {
                d2 *= gam*gam;
                h21 /= gam;
                h22 /= gam;
            } else {
                d2 /= gam*gam;
                h21 *= gam;
                h22 *= gam;
            }
        }
    }
  }

  return (d1, d2, x1, [flag, h11, h21, h12, h22]);
}


/*
 * drot
 */
inline
double[xn], double[yn] drot(int n, double[xn] x, int incx, double[yn] y, int incy, double c, double s) | n > 0, incx > 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return (
    {iv -> c*x[iv] + s*y[(iv*incy)/incx] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]},
    {iv -> c*y[iv] - s*x[(iv*incx)/incy] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]}
  );
}


/*
 * drotm
 */
inline
double[xn], double[yn] drotm(int n, double[xn] x, int incx, double[yn] y, int incy, double[5] param) | n > 0, ismember(param[0], [1.0, 0.0, -1.0, -2.0]), minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  flag = param[0];
  h11  = param[1];
  h21  = param[2];
  h12  = param[3];
  h22  = param[4];
  
  if(n < 1 || flag == -2d) {
    X_prime = x;
    Y_prime = y;
  } else if(flag < 0d) {
    X_prime = {i -> x[i]*h11 + y[(i*incy)/incx]*h12 | [0] <= i < [n*incx] step [incx] ; i -> x[i]};
    Y_prime = {i -> x[(i*incx)/incy]*h21 + y[i]*h22 | [0] <= i < [n*incy] step [incy] ; i -> y[i]};
  } else if(flag == 0d) {
    X_prime = {i -> x[i] + y[(i*incy)/incx]*h12 | [0] <= i < [n*incx] step [incx] ; i -> x[i]};
    Y_prime = {i -> x[(i*incx)/incy]*h21 + y[i] | [0] <= i < [n*incy] step [incy] ; i -> y[i]};
  } else {
    X_prime = {i ->  x[i]*h11 + y[(i*incy)/incx] | [0] <= i < [n*incx] step [incx] ; i -> x[i]};
    Y_prime = {i -> -x[(i*incx)/incy] + y[i]*h22 | [0] <= i < [n*incy] step [incy] ; i -> y[i]};
  }
  
  return (X_prime, Y_prime);
}


/*
 * dswap
 */
inline
double[xn], double[yn] dswap(int n, double[xn] x, int incx, double[yn] y, int incy) | n > 0, incx > 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return (
    {iv -> y[(iv/incx)*incy] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]},
    {iv -> x[(iv/incy)*incx] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]}
  );
}


/*
 * dscal
 */
inline
double[xn] dscal(int n, double a, double[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  return {iv -> a * x[iv] | [0] <= iv < [xn] step [incx] ; iv -> x[iv]};
}


/*
 * dcopy
 */
inline
double[yn] dcopy(int n, double[xn] x, int incx, double[yn] y, int incy) | n > 0, incx >= 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return {iv -> x[(iv/incy)*incx] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
}


/*
 * daxpy
 */
inline
double[yn] daxpy(int n, double a, double[xn] x, int incx, double[yn] y, int incy) | n > 0, incx >= 0, incy > 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  if(a == 0d) {
    result = y;
  } else {
    result = {iv -> a * x[(iv/incy)*incx] + y[iv] | [0] <= iv < [yn] step [incy] ; iv -> y[iv]};
  }
  return result;
}


/*
 * ddot
 */
inline
double ddot(int n, double[xn] x, int incx, double[yn] y, int incy) | n > 0, incx >= 0, incy >= 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return sum( {iv -> x[iv*incx] * y[iv*incy] | [0] <= iv < [n]} );
}


/*
 * dsdot
 */
inline
double dsdot(int n, float[xn] x, int incx, float[yn] y, int incy) | n > 0, incx >= 0, incy >= 0, minArrLen(n, xn, incx), minArrLen(n, yn, incy)
{
  return sum( {iv -> tod(x[iv*incx]) * tod(y[iv*incy]) | [0] <= iv < [n] } );
}


/*
 * dnrm2
 */
inline
double dnrm2(int n, double[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  return sqrt(sum( {iv -> x[iv]*x[iv] | [0] <= iv < [xn] step [incx]} ));
}


/*
 * dznrm2
 */
// inline
// double dznrm2(int n, complex[.] X, int incx) | n > 0, incx > 0
// {
//   X_prime = {i -> x[i*incx] | [0] <= i < [n] ; i -> zero() | i < [n*incx]};
//   return sqrt(sum(normSq(X_prime)));
// }


/*
 * dasum
 */
inline
double dasum(int n, double[xn] x, int incx) | n > 0, incx > 0
{
  return sum( {iv -> abs(x[iv]) | [0] <= iv < [xn] step [incx]} );
}


/*
 * idamax
 */
inline
int idamax(int n, double[xn] x, int incx) | n > 0, incx > 0, minArrLen(n, xn, incx)
{
  max_i = 0;
  max_v = 0d;
  ix = 0;
  for(i = 0; i < n; i++) {
    current_v = abs(x[ix]);
    if(current_v > max_v) {
      max_i = i;
      max_v = current_v;
    }
    ix += incx;
  }

  return max_i;
}
