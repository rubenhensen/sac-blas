/**********************************************************************
 *
 * SAC bug report: sgemv.sacbugreport
 *
 **********************************************************************
 *
 * Automatically generated on Mon May 27 01:11:16 PM CEST 2024
 *
 * using sac2c 1.3.3-MijasCosta-1238-gf2398
 * built 2024-05-23T12:26:24.
 * by user rubenhensen on host pop-os.
 *
 * The compiler was called by
 *  sac2c -D MODE=TEST -check tc -o sgemv test/sgemv.sac
 *
 * The compiler crashed in
 *  phase: opt (Running SAC optimizations)
 *  sub phase: cyc (Optimization cycle)
 *  cycle phase: lur (Applying loop unrolling)
 *  cycle instance: 2
 *
 * What follows is the contents of test/sgemv.sac.
 *
 **********************************************************************/

use StdIO: all;
use Array: all;
use BlasLevel1: all;
use BlasLevel2: all;
use Helper: all;
use Benchmarking: all;

// modes

#define TEST 0
#define NATIVE  1
#define LIBRARY 2
#define SINGLE 3
// #define MODE TEST


#ifndef N
#define N 10000000
#endif
#ifndef INCX
#define INCX 1
#endif
#ifndef INCY
#define INCY 1
#endif

#ifndef SAMPLE_RATE
#define SAMPLE_RATE 100
#endif

#define MAX_ACC_LOSS 0.001


// #ifndef MODE
// #define MODE ST
// #endif

#ifndef TYPE
#define TYPE INPUT_SIZE
#endif

//types
#define INPUT_SIZE   1
#define THREAD_COUNT 2

//modes
#define ST 1
#define MT  2

#ifndef THREADS
#define THREADS 1
#endif

//routines
// #define DROTG   1
// #define DROTMG  2
// #define DROT    3
// #define DROTM   4
// #define DSWAP   5
// #define DSCAL   6
// #define DCOPY   7
// #define DAXPY   8
// #define DDOT    9
// #define DSDOT  10
// #define DNRM2  11
// #define DZNRM2 12
// #define DASUM  13
// #define IDAMAX 14



int main() {
    #ifndef MODE
        printf("To generate measurements for a given routine:\n");
        printf("$ sac2c testing_tool.sac -D MODE=<routine name (CAPS)> && ./a.out > /dev/null 2>&1\n");
        printf("\nTo test correctness of all routines:\n");
        printf("$ sac2c testing_tool.sac -D MODE=TEST && ./a.out\n");
    #endif

    trans = ['n', 'N', 't', 'T', 'c', 'C', 'x', 'X'];

    nm = [1,2,3,4,10,100];

    perms_nm = {[i,j,k] -> [nm[i], nm[j], nm[k] >= nm[j] ? nm[k] : nm[j]]};
    perms_nm = reshape([shape(nm)[0]*shape(nm)[0]*shape(nm)[0], 3], perms_nm);
    // print(perms_nm);

    incs = [1,2,3,4];
    perms_incs = {[i,j] -> [incs[i], incs[j]]};
    perms_incs = reshape([shape(incs)[0]*shape(incs)[0], 2], perms_incs);
    // print(perms_incs);

    scalars = [0.0f, 1.0f, 0.0001f, 999.23478f, -1.0f, -0.0001f, -999.23478f];
    perms_scalars = {[i,j] -> [scalars[i], scalars[j]]};
    perms_scalars = reshape([shape(scalars)[0]*shape(scalars)[0], 2], perms_scalars);
    // print(perms_scalars);

    fs = [0.0f, 7.0f, 3.2f, -4.6f, -10.0f, 0.00000000003f, -0.00000000004f, 700000.0f, -4375.3f];
    perms_fs = { [i,j,k] -> [fs[i], fs[j], fs[k]] };
    perms_fs = reshape([shape(fs)[0]*shape(fs)[0]*shape(fs)[0], 3], perms_fs);
    // print(perms_fs);
    
    #ifdef MODE
    if(MODE == TEST) {
      // print("inside mode test");
      check(trans, perms_nm, perms_incs, perms_scalars, perms_fs, 10, MODE);
    } else if (MODE == SINGLE) {
      betaY =   BlasLevel1::sscal(4, 0.0f, tof([0]), 2);
      print(betaY);
      // a = genarray([4, 1], perms_fs[0][0]);
      // x = genarray([1+(4-1)*1], perms_fs[0][1]);
      // y = genarray([1+(1-1)*1], perms_fs[0][2]);
      // print(a);
      // print(tof([[0],[0],[0],[0]]));
      // print(x);
      // print(tof([0,0,0,0]));
      // print(y);
      // print(tof([0]));
      // compare('n', 4, 1, 0.0f, tof([[0],[0],[0],[0]]), 1, tof([0,0,0,0]), 1, 1.0f, y, 2);
    }
    //else if(TYPE == THREAD_COUNT) {
        // measure_thread_count(THREADS, ROUTINE);
    // } else {
        // measure_input_size(MODE, ROUTINE);
    // }
    #endif

    return 0;
}

void check(char[*] trans, int[*] perms_nm, int[*] perms_incs, float[*] perms_scalars, float[*] perms_fs, int sample_rate, int mode) {
  for (i = 0; i < shape(perms_nm)[0]; i++) {
    for (j = 0; j < shape(perms_incs)[0]; j++) {
      for (k = 0; k < shape(perms_scalars)[0]; k++) {
        for (l = 0; l < shape(perms_fs)[0]; l++) {
          for (p = 0; p < shape(trans)[0]; p++) {
            printf("i:%d j:%d k:%d l:%d, p:%d\n", i, j, k, l, p);
            trans = trans[[p]]; // This breaks the loop
            // i = 108;
            // j = 1;
            // k = 0;
            // l = 0;
            // p = 0;

            m = perms_nm[i][0];
            n = perms_nm[i][1];
            incx = perms_incs[j][0];
            incy = perms_incs[j][1];
            lda = perms_nm[i][2];
            alpha = perms_scalars[k][0];
            beta = perms_scalars[k][1];
            a = genarray([m, lda], perms_fs[l][0]);
            x = genarray([1+(m-1)*incx], perms_fs[l][1]);
            y = genarray([1+(n-1)*incy], perms_fs[l][2]);

            // print(m);
            // print(n);
            // print(incx);
            // print(incy);
            // print(lda);
            // print(alpha);
            // print(beta);
            // print(a);
            // print(x);
            // print(y);

            if (mode == TEST) {
              if (ismember('n', ['n', 'N', 't', 'T', 'c', 'C']) && m >= 0 && n >=0 && lda >= max(1,n) && sgemvXdim('n', m, n, incx, shape(x)[0]) && incx != 0 && sgemvYdim('n', m, n, incy, shape(y)[0]) && incy != 0)
              {
                compare('n', m, n, alpha, a, lda, x, incx, beta, y, incy);
              }
            }
          }
        }
      }
    }
  }
}


void compare(char trans, int m, int n, float alpha, float[am,an] a, int lda, float[xn] x, int incx, float beta, float[yn] y, int incy)
{
    y1 = OpenBlas::sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
    y2 = sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
    
    if(!(almost_eq(y1,y2)))
    {
        printf("Error in sgemv. trans:%c, m:%d, n:%d, alpha:%f, lda:%d, incx:%d, beta:%f, incy:%d\n", trans, m, n, alpha, lda, incx, beta, incy); 
        print(a);
        print(x);
        print(y);
        print(y1);
        print(y2);
        printf("\n");
    }
}

double time(int n, int version) {
  interval = getInterval("interval", 7, 1);
    X = genarray([n], 7d);
    Y = genarray([n], 4d);

    // m = cap_n(n, INCX, INCY);
    m = n;
    
    if(version == NATIVE) {
        start(interval);
        // Y = dcopy(m, X, INCX, Y, INCY);
        end(interval);
    } else {
        start(interval);
        // Y = cblas_dcopy(m, X, INCX, Y, INCY);
        end(interval);
    }

    printf("Y: ");
    // show(take([10], id(Y)));

    time, unit = returnResultUnit(interval);

    return time;
}

/*
*  The ?gemv routines perform a matrix-vector operation defined as:
*  y := alpha*A*x + beta*y,
*  or
*  y := alpha*A'*x + beta*y,
*  or
*  y := alpha*conjg(A')*x + beta*y,
*  where:
*    alpha and beta are scalars,
*    x and y are vectors,
*    A is an m-by-n matrix.
*/

// lda >= max(1,n) because row major sac

float[yn] sgemv(char trans, int m, int n, float alpha, float[am,an] a, int lda, float[xn] x, int incx, float beta, float[yn] y, int incy) | ismember(trans, ['n', 'N', 't', 'T', 'c', 'C']), m >= 0, n >=0, lda >= max(1,n), sgemvXdim(trans, m, n, incx, xn), incx != 0, sgemvYdim(trans, m, n, incy, yn), incy != 0
{
  if (trans == 'N' | trans == 'n') {
    lenx = n;
    leny = m;
  } else {
    lenx = m;
    leny = n;
    a = transpose(a);
  }

  betaY =   BlasLevel1::sscal(leny, beta, y, incy);
  alphaX =  {iv -> alpha * x[iv*incx]         | iv < [lenx]};
  resA =    {iv -> sum(a[iv] * alphaX)        | iv < [leny]};
  res =     {iv -> resA[iv/incy] +  betaY[iv] | iv <= [(leny-1)*incy] step [incy] ; iv -> y[iv]};

  return res;
}

void manual() {
    // manual unit testing
    compare('n', 4, 3, 1.0f, tof(reshape([4,3], iota(12))), 3, tof([1,1,1]), 1, 0.0f, tof([1,1,1,1]), 1);
    compare('n', 4, 3, 2.0f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 0.0f, tof([1,1,1,1]), 1);
    compare('n', 4, 3, 2.0f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 1.0f, tof([1,1,1,1]), 1);
    compare('n', 4, 3, 2.0f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 0.0f, tof(iota(4)), 1);
    compare('n', 4, 3, 2.0f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 1.0f, tof(iota(7)), 2);
    compare('n', 4, 3, 2.0f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 0.0f, tof(iota(7)), 2);
    compare('n', 4, 3, 0.3235f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 0.0f, tof(iota(9)), 2);
    compare('n', 4, 3, 1.0f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 33.0f, tof(iota(7)), 2);
    compare('n', 4, 3, 2.34556f, tof(reshape([4,3], iota(12))), 3, tof(iota(5)), 2, 42.7f, tof(iota(9)), 2);
    compare('t', 3, 4, 1.0f, tof(reshape([3,4], iota(12))), 4, tof([1,1,1]), 1, 0.0f, tof([1,1,1,1]), 1);
    compare('t', 3, 4, 2.0f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 0.0f, tof([1,1,1,1]), 1);
    compare('t', 3, 4, 2.0f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 1.0f, tof([1,1,1,1]), 1);
    compare('t', 3, 4, 2.0f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 0.0f, tof(iota(4)), 1);
    compare('t', 3, 4, 2.0f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 1.0f, tof(iota(7)), 2);
    compare('t', 3, 4, 2.0f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 0.0f, tof(iota(7)), 2);
    compare('t', 3, 4, 0.3235f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 0.0f, tof(iota(9)), 2);
    compare('t', 3, 4, 1.0f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 33.0f, tof(iota(7)), 2);
    compare('t', 3, 4, 2.34556f, tof(reshape([3,4], iota(12))), 4, tof(iota(5)), 2, 42.7f, tof(iota(9)), 2);
}

/**********************************************************************
 *
 * End of bug report
 *
 **********************************************************************/

