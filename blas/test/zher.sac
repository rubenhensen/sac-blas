use StdIO: all;
// use Array: all;
// use BlasLevel1: all;
// use BlasLevel2: all;
// use Helper: all;
use StructuresPlus: all;
use Math: all;


int main() {
    // x = [[1.0,1.0],[2.0,2.0],[3.0,3.0]];
    // x = with {
    //     (. <= iv <= .): toc(x[iv]);
    // }: genarray([shape(x)[0]], toc(0,0));
    // print(x);
    compare('u',1,1.0,[toc(1,1)],1,[[toc(1,1)]],1);
    // compare(2,2,1f,tof(iota(2)),1,tof(iota(2)),1,reshape([2,2],tof(iota(4))),2);
    // compare(3,2,1.333f,tof(iota(3)),1,tof(iota(2)),1,reshape([3,2],tof(iota(6))),2);
    // compare(3,2,1.333f,tof(iota(5)),2,tof(iota(2)),1,reshape([3,2],tof(iota(6))),2);
    // compare(3,2,1.333f,tof(iota(7)),3,tof(iota(2)),1,reshape([3,2],tof(iota(6))),2);
    // compare(3,2,1.333f,tof(iota(7)),3,tof(iota(8)),3,reshape([3,2],tof(iota(6))),2);
    return 0;
}

void compare(char uplo, int n, double alpha, complex[.] x, int incx, complex[*] a, int lda)
{
    // a1 = OpenBlas::zher(m, n, alpha, x, incx, y, incy, a, lda);

    a2 = zher(uplo, n, alpha, x, incx, a, lda);
    // print(a2);
    // if(!(all(a1 == a2) && all(shape(a1)==shape(a2)) && all(dim(a1)==dim(a2))))
    // {
    //     printf("Error in sger. m:%d, n:%d, alpha:%f, incx:%d, incy:%f, lda:%d", m, n, alpha, incx, incy, lda); 
    //     print(a);
    //     print(x);
    //     print(y);
    //     print(a1);
    //     print(a2);
    //     printf("\n");
    // }
}

complex[*] zher(char uplo, int n, double alpha, complex[.] x, int incx, complex[*] a, int lda)
{
    alphaX =  {iv -> alpha * x[iv*incx]         | iv < [n]};

    if (uplo == 'u' || uplo == 'U') {
        fullA =    {iv -> sum((conj(take(iv, transpose(a)[iv])) ++ drop(iv, a[iv]))) | iv < [n]};
    } else {
        fullA =    {iv -> sum((take(iv, a[iv]) ++ conj(drop(iv, transpose(a)[iv])))) | iv < [n]};
    }
    return fullA;
}

//   return {[i,j] -> a[i,j] + alpha * x[i*incx] * y[j*incy] | [i,j] < [m,n]};

// float[leny] ssymv(char uplo, int n, float alpha, float[d:shp] a, int lda, float[lenx] x, int incx, float beta, float[leny] y, int incy) | ismember(uplo, ['u', 'U', 'l', 'L'])
// {
//     betaY =   BlasLevel1::sscal(n, beta, y, incy);
//     alphaX =  {iv -> alpha * x[iv*incx]         | iv < [n]};
//     if (uplo == 'u' || uplo == 'U') {
//         resA =    {iv -> sum((take(iv, transpose(a)[iv]) ++ drop(iv, a[iv])) * alphaX) | iv < [n]};
//     } else {
//         resA =    {iv -> sum((take(iv, a[iv]) ++ drop(iv, transpose(a)[iv])) * alphaX) | iv < [n]};
//     }
//     res =     {iv -> resA[iv/incy] +  betaY[iv] | iv < [(n-1)*incy+1] step [incy] ; iv -> y[iv]};

//    return res;
// }

