module BlasLevel2;

use StdIO: all;
use Array: all;
// use Structures: all;
// use Math: all;
export all;

/*
* dgemv
* DGEMV  performs one of the matrix-vector operations
*
*    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
*
* where alpha and beta are scalars, x and y are vectors and A is an
* m by n matrix.
*/

// lda >= max(1,n) because row major sac

float[*] sgemv(char trans, int m, int n, float alpha, float[am,an] a, int lda, float[xn] x, int incx, float beta, float[yn] y, int incy) | ismember(trans, ['n', 'N', 't', 'T', 'c', 'C']), m >= 0, n >=0, lda >= max(1,n), sgemvXdim(trans, m, n, incx, xn), incx != 0, sgemvYdim(trans, m, n, incy, yn), incy != 0
{
  // Quick return if possible
  // if (m == 0 || n == 0 || (alpha == 0 && beta == 1)) return y; // not possible to return inside if statement

 
  // {i -> c*X[i] + s*Y[(i*incy)/incx] | [0] <= i < [n*incx] step [incx] ; i -> X[i]},
  if (trans == 'N' | trans == 'n') {
    lenx = n;
    leny = m;
  } else {
    lenx = m;
    leny = n;
  }

  // if (incx > 0) {
  //   kx = 1;
  // } else {
  //   kx = 1 - (lenx-1)*incx;
  // }

  // if (incy > 0) {
  //   ky = 1;
  // } else {
  //   ky = 1 - (lenx-1)*incy;
  // }
  
  // als beta niet gelijk is aan 1
    // als incy gelijk is aan 1
      // als beta gelijk is aan 0 -> dan zet alles in y op 0

  // does not incluce negative incy
  // calc betaY =  beta*y first
  // betaY =  BlasLevel1::sscal(leny, beta, y, incy);
  // return betaY;

  // calc alphaX = alpha * x
  // sscal(int n, float sa, float[k] sx, int incx) 
  alphaX =  BlasLevel1::sscal(lenx, alpha, x, incx);
  // alphaX = {i -> alpha * x[i] | [0] <= i <= [lenx*incx] step [incx] ; i -> x[i]};
  return alphaX;

  // calc resA = alphaX * a;]
  // resA = alphaX * a;
  // res = {i -> { j -> sum(a[j] * alphaX[j]) + betaY[i]  |  j < [lenx*incx] step [incx] ; j -> x[j]}  | i < [leny*incy] step [incy] ; i -> y[i]};

  // res = {[i,k] -> sum(a[i,.] * alphaX[k])  |  [i,k] < [m, lenx*incx] step [1,incx]; [i,k] -> x[i]};
  // return resA;
}

// int[i,k] matmul(int[i,j] a, int[j,k] b) {
//   return {[i,k] -> sum(a[i,.] * b[.,k])};
// }




//   res = {j -> mymul(a, alphaX, j)  |  j < [lenx*incx] step [incx] ; j -> x[j]};
//   // res = a[3]*alphaX;
//   return res;
// }

// float mymul(float[*] a, float[.] x, int[1] i ){
//   print(i);
//   print(a);
//   print(x);
//   res = a[i] *x;
//   print(res);
//   res = sum(res);
//   print(res);
//   return res;
// }


// matmul {[i,j] -> }

bool ismember(char c, char[n] ca)
{
  b = false;
  for(i=0; i<n;i++) {
    if (ca[i] == c) b = true;
  }
  return b;
}

// Checks max index of elements we go through is smaller than the length of x
bool sgemvXdim(char trans, int m, int n, int incx, int xn)
{
  if (trans == 'N' || trans == 'n') {
    res = xn > (n-1)*incx;
  } else {
    res = xn > (m-1)*incx;
  }
  return res;
}

bool sgemvYdim(char trans, int m, int n, int incy, int yn)
{
  if (trans == 'N' || trans == 'n') {
    res = yn > (m-1)*incy;
  } else {
    res = yn > (n-1)*incy;
  }
  return res;
}