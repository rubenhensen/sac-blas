use StdIO: all;
use Array: all;
use BlasLevel1: all;
// use BlasLevel2: all;
use Helper: all;

int main() {
    a = reshape([4,3], iota(12));
    a = tof(modarray(a, [3,2], 0));

    // compare('n', 4, 4, 1, 1, 1.0f,    a, 3, tof(iota(4)+1), 1, 0.0f, tof([1,1,1,1]), 1);

    return 0;
}


void compare(char uplo, char trans, char diag, int n, int k, float[an,am] a, int lda, float[xn] x, int incx)
{
    y1 = OpenBlas::stbmv(uplo, trans, diag, n, k, a, lda, x, incx);

    y2 = stbmv(uplo, trans, diag, n, k, a, lda, x, incx);

    if(!(eq(y1,y2)))
    {
        printf("Error in stbmv. uplo:%c, trans:%c, diag:%c, n:%d, k:%d, lda:%d, incx:%d\n", uplo, trans, diag, n, k, a, lda, x, incx); 
        print(a);
        print(x);
        print(y1);
        print(y2);
        printf("\n");
    }
}

float[xn] stbmv(char uplo, char trans, char diag, int n, int k, float[an,am] a, int lda, float[xn] x, int incx)
{
  // This should become precondition
  // if (trans == 'N' | trans == 'n') {
    // lenx = n;
    // leny = m;
  // } else {
  //   lenx = m;
  //   leny = n;
    // // storage to full -> transpose -> do gbmv
    // a = bandStorageToFull(a, kl, ku, m, n);
    // // print(a);
    // a = transpose(a);
    // // print(a);
    // a = fullStorageToBand(a, ku, kl, n, m);
    // // print(a);
  // }

  // betaY =   BlasLevel1::sscal(leny, beta, y, incy);
  // alphaX =  {iv -> alpha * x[iv*incx]         | iv < [lenx]};

  // resA = { [i] -> sum(padVectorBack(an,drop([kl-i], a[i]))   * take([an], alphaX))    | [i] < [kl];
  //          [i] -> sum(a[i]              * take([an], drop([i-1],alphaX)))      | [i] < [am] };

  // res =     {iv -> resA[iv/incy] +  betaY[iv] | iv <= [(leny-1)*incy] step [incy] ; iv -> y[iv]};
  
  return x;
}

// // Checks max index of elements we go through is smaller than the length of x
// bool sgemvXdim(char trans, int m, int n, int incx, int xn)
// {
//   if (trans == 'N' || trans == 'n') {
//     res = minArrLen(n, xn, incx);
//   } else {
//     res = minArrLen(m, xn, incx);
//   }
//   return res;
// }

// bool sgemvYdim(char trans, int m, int n, int incy, int yn)
// {
//   if (trans == 'N' || trans == 'n') {
//     res = minArrLen(m, yn, incy);
//   } else {
//     res = minArrLen(n, yn, incy);
//   }
//   return res;
// }

// // float[m,n]
// float[m,n] bandStorageToFull(float[m,lda] storage, int kl, int ku, int m, int n)
// {
//   lim = n-ku;

//   return { [i] -> padVectorBack(n, drop([kl-i], storage[i]))  | [i] < [kl];
//            [i] -> padVectorOffset(n, i-kl, storage[i])      | [kl] <= [i] < [lim];
//            [i] -> padVectorFront(n,take([kl+1], storage[i]))  | [i] < [m] };
// }

// // float[m,lda]
// float[m,lda] fullStorageToBand(float[m,n] storage, int kl, int ku, int m, int n)
// {
//   lim = n-ku;
//   w = kl + ku + 1;
//   return {  [i] -> padVectorFront(w, take([i+ku+1], drop([max(0,i-kl)],storage[i])))  | [i] < [kl];
//             [i] -> take([w], drop([i-kl],storage[i]))                                 | [i] < [lim];
//             [i] -> padVectorBack(w,take([min(w,w-(i-lim))],drop([i-kl], storage[i]))) | [i] < [m]};
// }

// // print(padVectorFront(10, tof(iota(5)*2)));

// float[m] padVectorFront(int k, float[n] arr)
// {
//   zeros = [k-n];
//   return { iv -> 0.0f           | iv < zeros;
//            iv -> arr[iv-zeros]  | zeros <= iv < [k]
//          };
// }

// float[m] padVectorBack(int k, float[n] arr)
// {
//   return { iv -> arr[iv]  | iv < [n];
//            iv -> 0.0f     | [n] <= iv < [k]       
//          };
// }

// float[m] padVectorOffset(int k, int offset, float[n] arr) | offset >= 0
// {
//   return { iv -> 0.0f             | iv < [offset];  
//            iv -> arr[iv-offset]   | [offset] <= iv < [n+offset];
//            iv -> 0.0f             | [offset+n] <= iv < [k]       
//          };
// }