use StdIO: all;
use Array: all;
use BlasLevel1: all;
use BlasLevel2: all;
// use Openblas: all;

int main() {
    // Blas 1
    // X = tod(iota(10));
    // Y = tod(iota(10)) + 10.0;
    // print(X);
    // print(Y);

    // Xp, Yp = dswap(10, X, 1, Y, 1);
    // print(Xp);
    // print(Yp);

    // Xp, Yp = dswap(5, X, 2, Y, 2);
    // print(Xp);
    // print(Yp);

    // print([[1,2,3],[3,4,5]]);
    // print([[2,3]]);

    // Blas 2
    // a = dgemv('n', 1,2, 0.0, [[0.0, 0.0]], 1, [0.0, 0.0, 0.0], 1, 0.0, [0.0], 1);
    // print(a);
    // srand(time(NULL));   // Initialization, should only be called once.
    // int r = rand();
    // print(r);
    // print( compareSrotg(0.0f, 0.0f, 0.0f, 0.0f) );


    // gemv
    trans = 'n';
    m = 4;
    n = 3; 
    alpha = 1.0f;
    a = tof(reshape([4,3], iota(12)));
    lda = 3;
    x = tof([1,1,1]);
    incx = 1;
    beta = 0.0f;
    y = tof([1,1,1,1]);
    incy = 1;
    print(compareSgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy));

    // // gemv
    trans = 'n';
    m = 4;
    n = 3; 
    alpha = 1.0f;
    a = tof(reshape([4,3], iota(12)));
    lda = 3;
    x = tof([1,6,1,6,1]);
    incx = 2;
    beta = 0.0f;
    y = tof([1,1,1,1]);
    incy = 1;
    print(compareSgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy));

    // // gemv
    // trans = 'n';
    // m = 4;
    // n = 3; 
    // alpha = 1.0f;
    // a = tof(reshape([4,3], iota(12)));
    // lda = 3;
    // x = tof([1,1,1]);
    // incx = 1;
    // beta = 1.0f;
    // y = tof([1,1,1,1]);
    // incy = 1;
    // b = reshape([3,4], iota(12));
    // print(compareSgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy));

    // // gemv
    // trans = 'n';
    // m = 4;
    // n = 3; 
    // alpha = 1.0f;
    // a = tof(reshape([4,3], iota(12)));
    // lda = 3;
    // x = tof([1,1,1]);
    // incx = 1;
    // beta = 2.0f;
    // y = tof([1,1,1,1]);
    // incy = 1;
    // b = reshape([3,4], iota(12));
    // print(compareSgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy));
    
    // // gemv
    // trans = 'n';
    // m = 4;
    // n = 3; 
    // alpha = 1.0f;
    // a = tof(reshape([4,3], iota(12)));
    // lda = 3;
    // x = tof([1,1,1]);
    // incx = 1;
    // beta = 3.0f;
    // y = tof([1,1,1,1]);
    // incy = 1;
    // b = reshape([3,4], iota(12));
    // print(compareSgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy));

    // a = reshape([2,3], iota(6));
    // b = reshape([3,2], iota(6));
    // print( matmul(a,b) );
    // print( matmul2(a,b) );

//    a = with {
//          ([0,2] <= [i,j] < [5,6]): 42;
//        }: genarray([5,6], 0);
//    print(a);

//     shp = [5,6];
//     a = with {
//           (0*shp <= iv < shp): 42;
//         }: genarray(shp, 0);
//     print(a);

//     a = with {
//           (. < iv < .): 42;
//         }: genarray([5,6], 0);
//     print(a);

//     a = with {
//           (. <= jv=[x,y] <= [4,5]): 42;
//         }: genarray( [5,6], 0);
//     print(a);

//     a = with {
//           (. <= [i,j] <= . step [1,4]): 42;
//         }: genarray([5,6], 0);
//     print(a);

//     // a = with {
//     //       (. <= [i,j] <= . step [2,4] width [1,2]): 42;
//     //     }: genarray([5,6], 0);
//     // print(a);
//     x = tof([1,2,1,2,1]);
//     a = {[i] -> x[i] | [i] < [5] step [2]; i -> x[i]};
//     print(a);
    return 0;
}

int[i,k] matmul(int[i,j] a, int[j,k] b) {
  return {[i,k] -> sum(a[i,.] * b[.,k])};
}

int[*] matmul2(int[i,j] a, int[j,k] b) {
  return {[i,k] -> a[i,.] * b[.,k]};
}
bool compareSgemv(char trans, int m, int n, float alpha, float[am,an] a, int lda, float[xn] x, int incx, float beta, float[yn] y, int incy)
{
    res1 = Openblas::sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
    print(res1);

    res2 = sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy);
    print(res2);
    
    return eq(res1,res2);
}

bool compareSrotg(float a, float b, float c, float s)
{
    r1, z1, c1, s1 = Openblas::srotg(a, b, c, s);
    r2, z2, c2, s2 = srotg(a, b, c, s);
    
    return r1 == r2 && z1 == z2 && c1 == c2 && s1 == s2;
}

bool eq (int[d1:shp1] a, int[d2:shp2] b) {
    return all(a == b) && all(shp1==shp2) && all(d1==d2);
}

bool eq (float[d1:shp1] a, float[d2:shp2] b) {
    return all(a == b) && all(shp1==shp2) && all(d1==d2);
}

// bool eq (int[n] a, int[m] b) {
//     return all(a == b) && all(n == m);
// }

// bool eq (int[n] a, int[m] b) {
//     return all(a == b) && all(n == m);
// }



// sac2c -v0 -noprelude -cc ccrmod -o ./src/srotg.o ./src/srotg.c && sac2c -Xl -lopenblas Openblas.sac && sac2c  blas.sac  && ./a.out 