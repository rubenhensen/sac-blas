use StdIO: all;
use Array: all;
// use BlasLevel1: all;
use BlasLevel2: all;
use Helper: all;

int main() {

    return 0;
}

void compare(char uplo, int n, float alpha, float[*] a, int lda, float[*] x, int incx, float beta, float[*] y, int incy)
{
    y1 = OpenBlas::ssymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy);
    y2 = ssymv(uplo, n, alpha, a, lda, x, incx, beta, y, incy);
    
    if(!(almost_eq(y1,y2)))
    {
        printf("Error in ssymv. uplo:%d, n:%d, alpha:%f, lda:%d, incx:%d, beta:%f, incy:%d\n", uplo, n, alpha, lda, incx, beta, incy); 
        print(a);
        print(x);
        print(y);
        print(y1);
        print(y2);
        printf("\n");
    }
}

float[leny] sspmv(char uplo, int n, float alpha, float[d:shp] a, int lda, float[lenx] x, int incx, float beta, float[leny] y, int incy) | ismember(uplo, ['u', 'U', 'l', 'L'])
{
    betaY =   BlasLevel1::sscal(n, beta, y, incy);
    alphaX =  {iv -> alpha * x[iv*incx]         | iv < [n]};
    if (uplo == 'u' || uplo == 'U') {
        resA =    {iv -> sum((take(iv, transpose(a)[iv]) ++ drop(iv, a[iv])) * alphaX) | iv < [n]};
    } else {
        resA =    {iv -> sum((take(iv, a[iv]) ++ drop(iv, transpose(a)[iv])) * alphaX) | iv < [n]};
    }
    res =     {iv -> resA[iv/incy] +  betaY[iv] | iv <= [(n-1)*incy] step [incy] ; iv -> y[iv]};

   return res;
}
