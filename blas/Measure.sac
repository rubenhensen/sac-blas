use Benchmarking: all;
use StdIO: all;

#ifndef N
#define N 10000000
#endif
#ifndef INCX
#define INCX 1
#endif
#ifndef INCY
#define INCY 1
#endif

#ifndef SAMPLE_RATE
#define SAMPLE_RATE 100
#endif

#define MAX_ACC_LOSS 0.001


#ifndef MODE
#define MODE ST
#endif

#ifndef TYPE
#define TYPE INPUT_SIZE
#endif

//types
#define INPUT_SIZE   1
#define THREAD_COUNT 2

//modes
#define ST 1
#define MT  2

#ifndef THREADS
#define THREADS 1
#endif

//versions
#define NATIVE  1
#define LIBRARY 2

//routines
#define DROTG   1
#define DROTMG  2
#define DROT    3
#define DROTM   4
#define DSWAP   5
#define DSCAL   6
#define DCOPY   7
#define DAXPY   8
#define DDOT    9
#define DSDOT  10
#define DNRM2  11
#define DZNRM2 12
#define DASUM  13
#define IDAMAX 14

#define TEST    0


/*
 * MAIN
 */
int main() {
    #ifndef ROUTINE
        printf("To generate measurements for a given routine:\n");
        printf("$ sac2c testing_tool.sac -D ROUTINE=<routine name (CAPS)> && ./a.out > /dev/null 2>&1\n");
        printf("\nTo test correctness of all routines:\n");
        printf("$ sac2c testing_tool.sac -D ROUTINE=TEST && ./a.out\n");
    #endif

    #ifdef ROUTINE
    if(ROUTINE == TEST) {
        test();
    } else if(TYPE == THREAD_COUNT) {
        measure_thread_count(THREADS, ROUTINE);
    } else {
        measure_input_size(MODE, ROUTINE);
    }
    #endif
    return 0;
}

double[*] run(int routine, int version, int n, int sample_rate) {
    m = cap_n(n, INCX, INCY);
    times = genarray([sample_rate], 0.0);
    
    for(i = 0; i < sample_rate; i++) {
        //X = id(genarray([n], tod(i)+7d));
        //Y = id(genarray([n], tod(i)+4d));
        //param = id([-1d, 2d, 3d, 4d, 5d]);
        //a = id(2d);
        //b = id(3d);
        //c = id(4d);
        //d = id(5d);

        if(routine == DROTG) {
            time = measure_drotg(version);
        } else if(routine == DROTMG) {
            time = measure_drotmg(version);
        } else if(routine == DROT) {
            time = measure_drot(version, n);
        } else if(routine == DROTM) {
            time = measure_drotm(version, n);
        } else if(routine == DSWAP) {
            time = measure_dswap(version, n);
        } else if(routine == DSCAL) {
            time = measure_dscal(version, n);
        } else if(routine == DCOPY) {
            time = measure_dcopy(version, n);
        } else if(routine == DAXPY) {
            time = measure_daxpy(version, n);
        } else if(routine == DDOT) {
            time = measure_ddot(version, n);
        } else if(routine == DSDOT) {
            time = measure_dsdot(version, n);
        } else if(routine == DNRM2) {
            time = measure_dnrm2(version, n);
        } else if(routine == DZNRM2) {
            time = measure_dznrm2(version, n);
        } else if(routine == DASUM) {
            time = measure_dasum(version, n);
        } else if(routine == IDAMAX) {
            time = measure_idamax(version, n);
        } else {
            time = 0.0;
        }
        
        times[i] = time;
    }

    return times;
}

void measure_thread_count(int thread_count, int routine) {
    output_path = "../../graphs/data/" + routine_id_to_name(routine) + ".out";

    //define n as smaller than N, because we want everything to stay within L3 cache for this measurement.
    n = 1000000;

    if(thread_count == 1) {
        //clear the output file now, since the log_data function only appends new data
        err, file = fopen(output_path, "w");
        //write some additional info at the top of the file
        fprintf(file, "%i,%i,%i\n", n, INCX, INCY);
        fclose(file);

        times_nat = run(routine, NATIVE,  n, SAMPLE_RATE);
        log_datapoint(output_path, thread_count, times_nat);
    }

    times_nat = run(routine, NATIVE,  n, SAMPLE_RATE);
    log_datapoint(output_path, thread_count, times_nat);
}

void test() {
    print("not implemented");
}


string routine_id_to_name(int routine) {
    if(routine == DROTG) {
        result = "drotg";
    } else if(routine == DROTMG) {
        result = "drotmg";
    } else if(routine == DROT) {
        result = "drot";
    } else if(routine == DROTM) {
        result = "drotm";
    } else if(routine == DSWAP) {
        result = "dswap";
    } else if(routine == DSCAL) {
        result = "dscal";
    } else if(routine == DCOPY) {
        result = "dcopy";
    } else if(routine == DAXPY) {
        result = "daxpy";
    } else if(routine == DDOT) {
        result = "ddot";
    } else if(routine == DSDOT) {
        result = "dsdot";
    } else if(routine == DNRM2) {
        result = "dnrm2";
    } else if(routine == DZNRM2) {
        result = "dznrm2";
    } else if(routine == DASUM) {
        result = "dasum";
    } else if(routine == IDAMAX) {
        result = "idamax";
    } else {
        result = "unknown";
    }
    return result;
}