module BlasLevel2;

use StdIO: all;
use Array: all;
use Helper: all;
// use Structures: all;
// use Math: all;
export all;

/*
* sgemv
* SGEMV  performs one of the matrix-vector operations
*
*    y := alpha*A*x + beta*y,   or   y := alpha*A**T*x + beta*y,
*
* where alpha and beta are scalars, x and y are vectors and A is an
* m by n matrix.
*/

// lda >= max(1,n) because row major sac

float[yn] sgemv(char trans, int m, int n, float alpha, float[am,an] a, int lda, float[xn] x, int incx, float beta, float[yn] y, int incy) | ismember(trans, ['n', 'N', 't', 'T', 'c', 'C']), m >= 0, n >=0, lda >= max(1,n), sgemvXdim(trans, m, n, incx, xn), incx != 0, sgemvYdim(trans, m, n, incy, yn), incy != 0
{
  if (trans == 'N' | trans == 'n') {
    lenx = n;
    leny = m;
  } else {
    lenx = m;
    leny = n;
    a = transpose(a);
  }

  betaY =   BlasLevel1::sscal(leny, beta, y, incy);
  alphaX =  {iv -> alpha * x[iv*incx]         | [0] <= iv < [lenx]};
  resA =    {iv -> sum(a[iv] * alphaX)        | iv < [leny]};
  res =     {iv -> resA[iv/incy] +  betaY[iv] | iv < [(leny-1)*incy+1] step [incy] ; iv -> y[iv]};

  return res;
}

// Checks max index of elements we go through is smaller than the length of x
bool sgemvXdim(char trans, int m, int n, int incx, int xn)
{
  if (trans == 'N' || trans == 'n') {
    res = minArrLen(n, xn, incx);
  } else {
    res = minArrLen(m, xn, incx);
  }
  return res;
}

bool sgemvYdim(char trans, int m, int n, int incy, int yn)
{
  if (trans == 'N' || trans == 'n') {
    res = minArrLen(m, yn, incy);
  } else {
    res = minArrLen(n, yn, incy);
  }
  return res;
}